# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCountry {
  _count: CountryCountAggregate
  _max: CountryMaxAggregate
  _min: CountryMinAggregate
}

type AggregateItem {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
}

type AggregateType {
  _count: TypeCountAggregate
  _max: TypeMaxAggregate
  _min: TypeMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Country {
  _count: CountryCount
  emoji: String
  id: String!
  image: CountryImage
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  name: String!
}

type CountryCount {
  items: Int!
}

type CountryCountAggregate {
  _all: Int!
  emoji: Int!
  id: Int!
  name: Int!
}

input CountryCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CountryCreateNestedOneWithoutItemsInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutItemsInput
  create: CountryCreateWithoutItemsInput
}

input CountryCreateOrConnectWithoutItemsInput {
  create: CountryCreateWithoutItemsInput!
  where: CountryWhereUniqueInput!
}

input CountryCreateWithoutItemsInput {
  id: String!
  name: String!
}

type CountryGroupBy {
  _count: CountryCountAggregate
  _max: CountryMaxAggregate
  _min: CountryMinAggregate
  emoji: String
  id: String!
  name: String!
}

type CountryImage {
  urlPng40: String!
  urlPng80: String!
  urlPng160: String!
  urlPng320: String!
  urlPng640: String!
  urlPng1280: String!
  urlPng2560: String!
  urlSvg: String!
}

type CountryMaxAggregate {
  emoji: String
  id: String
  name: String
}

input CountryMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type CountryMinAggregate {
  emoji: String
  id: String
  name: String
}

input CountryMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CountryOrderByWithAggregationInput {
  _count: CountryCountOrderByAggregateInput
  _max: CountryMaxOrderByAggregateInput
  _min: CountryMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input CountryOrderByWithRelationInput {
  id: SortOrder
  items: ItemOrderByRelationAggregateInput
  name: SortOrder
}

input CountryRelationFilter {
  is: CountryWhereInput
  isNot: CountryWhereInput
}

enum CountryScalarFieldEnum {
  emoji
  id
  name
}

input CountryScalarWhereWithAggregatesInput {
  AND: [CountryScalarWhereWithAggregatesInput!]
  NOT: [CountryScalarWhereWithAggregatesInput!]
  OR: [CountryScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input CountryUpdateOneWithoutItemsNestedInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutItemsInput
  create: CountryCreateWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  update: CountryUpdateWithoutItemsInput
  upsert: CountryUpsertWithoutItemsInput
}

input CountryUpdateWithoutItemsInput {
  name: String
}

input CountryUpsertWithoutItemsInput {
  create: CountryCreateWithoutItemsInput!
  update: CountryUpdateWithoutItemsInput!
}

input CountryWhereInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  id: StringFilter
  items: ItemListRelationFilter
  name: StringFilter
}

input CountryWhereUniqueInput {
  id: String
  name: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input FloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

type Item {
  country: Country
  countryId: String
  createdAt: DateTime!
  id: String!
  image: ItemImage
  name: String!
  strength: Float
  type: Type
  typeId: String
  updatedAt: DateTime!
  user: User
  userId: String
}

type ItemAvgAggregate {
  strength: Float
}

input ItemAvgOrderByAggregateInput {
  strength: SortOrder
}

type ItemCountAggregate {
  _all: Int!
  countryId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  strength: Int!
  typeId: Int!
  updatedAt: Int!
  userId: Int!
}

input ItemCountOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

input ItemCreateInput {
  country: CountryCreateNestedOneWithoutItemsInput
  name: String!
  strength: Float
  type: TypeCreateNestedOneWithoutItemsInput
  user: UserCreateNestedOneWithoutItemsInput
}

input ItemCreateManyInput {
  countryId: String
  name: String!
  strength: Float
  typeId: String
  userId: String
}

type ItemGroupBy {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
  countryId: String
  createdAt: DateTime!
  id: String!
  name: String!
  strength: Float
  typeId: String
  updatedAt: DateTime!
  userId: String
}

type ItemImage {
  urlJpg: String!
  urlJpg100: String!
  urlJpg300: String!
  urlJpg500: String!
  urlJpg750: String!
  urlJpg1000: String!
  urlJpg1500: String!
  urlJpg2500: String!
}

input ItemListRelationFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

type ItemMaxAggregate {
  countryId: String
  createdAt: DateTime
  id: String
  name: String
  strength: Float
  typeId: String
  updatedAt: DateTime
  userId: String
}

input ItemMaxOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

type ItemMinAggregate {
  countryId: String
  createdAt: DateTime
  id: String
  name: String
  strength: Float
  typeId: String
  updatedAt: DateTime
  userId: String
}

input ItemMinOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input ItemOrderByWithAggregationInput {
  _avg: ItemAvgOrderByAggregateInput
  _count: ItemCountOrderByAggregateInput
  _max: ItemMaxOrderByAggregateInput
  _min: ItemMinOrderByAggregateInput
  _sum: ItemSumOrderByAggregateInput
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByWithRelationInput {
  country: CountryOrderByWithRelationInput
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  type: TypeOrderByWithRelationInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
}

enum ItemScalarFieldEnum {
  countryId
  createdAt
  id
  name
  strength
  typeId
  updatedAt
  userId
}

input ItemScalarWhereWithAggregatesInput {
  AND: [ItemScalarWhereWithAggregatesInput!]
  NOT: [ItemScalarWhereWithAggregatesInput!]
  OR: [ItemScalarWhereWithAggregatesInput!]
  countryId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  strength: FloatNullableWithAggregatesFilter
  typeId: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringNullableWithAggregatesFilter
}

type ItemSumAggregate {
  strength: Float
}

input ItemSumOrderByAggregateInput {
  strength: SortOrder
}

input ItemUpdateInput {
  country: CountryUpdateOneWithoutItemsNestedInput
  name: String
  strength: Float
  type: TypeUpdateOneWithoutItemsNestedInput
  user: UserUpdateOneWithoutItemsNestedInput
}

input ItemUpdateManyMutationInput {
  name: String
  strength: Float
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  country: CountryRelationFilter
  countryId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  strength: FloatNullableFilter
  type: TypeRelationFilter
  typeId: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringNullableFilter
}

input ItemWhereUniqueInput {
  id: String
  name: String
}

type Mutation {
  createManyItem(data: [ItemCreateManyInput!]!, skipDuplicates: Boolean, uploadImages: [Upload!]): AffectedRowsOutput!
  createManyType(data: [TypeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneItem(data: ItemCreateInput!, uploadImage: Upload): Item!
  createOneType(data: TypeCreateInput!): Type!
  createOneUser(data: UserCreateInput!): User!
  deleteManyItem(where: ItemWhereInput): AffectedRowsOutput!
  deleteManyType(where: TypeWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneItem(where: ItemWhereUniqueInput!): Item
  deleteOneType(where: TypeWhereUniqueInput!): Type
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyItem(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): AffectedRowsOutput!
  updateManyType(data: TypeUpdateManyMutationInput!, where: TypeWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneItem(data: ItemUpdateInput!, deleteImage: Boolean, uploadImage: Upload, where: ItemWhereUniqueInput!): Item!
  updateOneType(data: TypeUpdateInput!, where: TypeWhereUniqueInput!): Type
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneItem(create: ItemCreateInput!, deleteImage: Boolean, update: ItemUpdateInput!, uploadImage: Upload, where: ItemWhereUniqueInput!): Item!
  upsertOneType(create: TypeCreateInput!, update: TypeUpdateInput!, where: TypeWhereUniqueInput!): Type!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateCountry(cursor: CountryWhereUniqueInput, orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): AggregateCountry!
  aggregateItem(cursor: ItemWhereUniqueInput, orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): AggregateItem!
  aggregateType(cursor: TypeWhereUniqueInput, orderBy: [TypeOrderByWithRelationInput!], skip: Int, take: Int, where: TypeWhereInput): AggregateType!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  countries(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): [Country!]!
  findFirstCountryOrThrow(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): Country
  findFirstItemOrThrow(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): Item
  findFirstTypeOrThrow(cursor: TypeWhereUniqueInput, distinct: [TypeScalarFieldEnum!], orderBy: [TypeOrderByWithRelationInput!], skip: Int, take: Int, where: TypeWhereInput): Type
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCountry(where: CountryWhereUniqueInput!): Country
  getItem(where: ItemWhereUniqueInput!): Item
  getType(where: TypeWhereUniqueInput!): Type
  getUser(where: UserWhereUniqueInput!): User
  groupByCountry(by: [CountryScalarFieldEnum!]!, having: CountryScalarWhereWithAggregatesInput, orderBy: [CountryOrderByWithAggregationInput!], skip: Int, take: Int, where: CountryWhereInput): [CountryGroupBy!]!
  groupByItem(by: [ItemScalarFieldEnum!]!, having: ItemScalarWhereWithAggregatesInput, orderBy: [ItemOrderByWithAggregationInput!], skip: Int, take: Int, where: ItemWhereInput): [ItemGroupBy!]!
  groupByType(by: [TypeScalarFieldEnum!]!, having: TypeScalarWhereWithAggregatesInput, orderBy: [TypeOrderByWithAggregationInput!], skip: Int, take: Int, where: TypeWhereInput): [TypeGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  types(cursor: TypeWhereUniqueInput, distinct: [TypeScalarFieldEnum!], orderBy: [TypeOrderByWithRelationInput!], skip: Int, take: Int, where: TypeWhereInput): [Type!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

"""User roles"""
enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Type {
  _count: TypeCount
  id: String!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  name: String!
}

type TypeCount {
  items: Int!
}

type TypeCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input TypeCountOrderByAggregateInput {
  name: SortOrder
}

input TypeCreateInput {
  name: String!
}

input TypeCreateManyInput {
  name: String!
}

input TypeCreateNestedOneWithoutItemsInput {
  connect: TypeWhereUniqueInput
  connectOrCreate: TypeCreateOrConnectWithoutItemsInput
  create: TypeCreateWithoutItemsInput
}

input TypeCreateOrConnectWithoutItemsInput {
  create: TypeCreateWithoutItemsInput!
  where: TypeWhereUniqueInput!
}

input TypeCreateWithoutItemsInput {
  name: String!
}

type TypeGroupBy {
  _count: TypeCountAggregate
  _max: TypeMaxAggregate
  _min: TypeMinAggregate
  id: String!
  name: String!
}

type TypeMaxAggregate {
  id: String
  name: String
}

input TypeMaxOrderByAggregateInput {
  name: SortOrder
}

type TypeMinAggregate {
  id: String
  name: String
}

input TypeMinOrderByAggregateInput {
  name: SortOrder
}

input TypeOrderByWithAggregationInput {
  _count: TypeCountOrderByAggregateInput
  _max: TypeMaxOrderByAggregateInput
  _min: TypeMinOrderByAggregateInput
  name: SortOrder
}

input TypeOrderByWithRelationInput {
  items: ItemOrderByRelationAggregateInput
  name: SortOrder
}

input TypeRelationFilter {
  is: TypeWhereInput
  isNot: TypeWhereInput
}

enum TypeScalarFieldEnum {
  id
  name
}

input TypeScalarWhereWithAggregatesInput {
  AND: [TypeScalarWhereWithAggregatesInput!]
  NOT: [TypeScalarWhereWithAggregatesInput!]
  OR: [TypeScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input TypeUpdateInput {
  name: String
}

input TypeUpdateManyMutationInput {
  name: String
}

input TypeUpdateOneWithoutItemsNestedInput {
  connect: TypeWhereUniqueInput
  connectOrCreate: TypeCreateOrConnectWithoutItemsInput
  create: TypeCreateWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  update: TypeUpdateWithoutItemsInput
  upsert: TypeUpsertWithoutItemsInput
}

input TypeUpdateWithoutItemsInput {
  name: String
}

input TypeUpsertWithoutItemsInput {
  create: TypeCreateWithoutItemsInput!
  update: TypeUpdateWithoutItemsInput!
}

input TypeWhereInput {
  AND: [TypeWhereInput!]
  NOT: [TypeWhereInput!]
  OR: [TypeWhereInput!]
  id: StringFilter
  items: ItemListRelationFilter
  name: StringFilter
}

input TypeWhereUniqueInput {
  id: String
  name: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  _count: UserCount
  createdAt: DateTime!
  email: String!

  """User ID (UUID v4)"""
  id: String!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  name: String!
  role: Role!
  updatedAt: DateTime!
}

type UserCount {
  items: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  email: String!
  name: String!
  password: String!
}

input UserCreateNestedOneWithoutItemsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutItemsInput
  create: UserCreateWithoutItemsInput
}

input UserCreateOrConnectWithoutItemsInput {
  create: UserCreateWithoutItemsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutItemsInput {
  email: String!
  name: String!
  password: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime!
  email: String!
  id: String!
  name: String!
  password: String!
  role: Role!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  password: String
  role: Role
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  password: String
  role: Role
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  items: ItemOrderByRelationAggregateInput
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  password
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  email: String
  name: String
  password: String
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
}

input UserUpdateOneWithoutItemsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutItemsInput
  create: UserCreateWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutItemsInput
  upsert: UserUpsertWithoutItemsInput
}

input UserUpdateWithoutItemsInput {
  email: String
  name: String
  password: String
}

input UserUpsertWithoutItemsInput {
  create: UserCreateWithoutItemsInput!
  update: UserUpdateWithoutItemsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  items: ItemListRelationFilter
  name: StringFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  name: String
}