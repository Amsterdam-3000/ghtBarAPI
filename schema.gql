# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCountry {
  _count: CountryCountAggregate
  _max: CountryMaxAggregate
  _min: CountryMinAggregate
}

type AggregateItem {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
}

type AggregateType {
  _count: TypeCountAggregate
  _max: TypeMaxAggregate
  _min: TypeMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Country {
  _count: CountryCount

  """
  Country emoji: unicode blocks of emoji (check https://emojipedia.org/flags/)
  """
  emoji: String

  """Country ID: country code (ISO 3166-1 alpha-2)"""
  id: String!

  """Country flag: object is generated dynamically"""
  image: CountryImage

  """Country items: all items from this country"""
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!

  """Country name: must be unique"""
  name: String!
}

type CountryCount {
  items(where: ItemWhereInput): Int!
}

type CountryCountAggregate {
  _all: Int!
  emoji: Int!
  id: Int!
  name: Int!
}

input CountryCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CountryCreateNestedOneWithoutItemsInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutItemsInput
  create: CountryCreateWithoutItemsInput
}

input CountryCreateOrConnectWithoutItemsInput {
  create: CountryCreateWithoutItemsInput!
  where: CountryWhereUniqueInput!
}

input CountryCreateWithoutItemsInput {
  id: String!
  name: String!
}

type CountryGroupBy {
  _count: CountryCountAggregate
  _max: CountryMaxAggregate
  _min: CountryMinAggregate
  emoji: String
  id: String!
  name: String!
}

"""Country image: object with links to flag images of the country"""
type CountryImage {
  """Link to the PNG image with 40px width"""
  urlPng40: String!

  """Link to the PNG image with 80px width"""
  urlPng80: String!

  """Link to the PNG image with 160px width"""
  urlPng160: String!

  """Link to the PNG image with 320px width"""
  urlPng320: String!

  """Link to the PNG image with 640px width"""
  urlPng640: String!

  """Link to the PNG image with 1280px width"""
  urlPng1280: String!

  """Link to the PNG image with 2560px width"""
  urlPng2560: String!

  """Link to the SVG image"""
  urlSvg: String!
}

type CountryMaxAggregate {
  emoji: String
  id: String
  name: String
}

input CountryMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type CountryMinAggregate {
  emoji: String
  id: String
  name: String
}

input CountryMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CountryNullableRelationFilter {
  is: CountryWhereInput
  isNot: CountryWhereInput
}

input CountryOrderByWithAggregationInput {
  _count: CountryCountOrderByAggregateInput
  _max: CountryMaxOrderByAggregateInput
  _min: CountryMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input CountryOrderByWithRelationInput {
  id: SortOrder
  items: ItemOrderByRelationAggregateInput
  name: SortOrder
}

enum CountryScalarFieldEnum {
  emoji
  id
  name
}

input CountryScalarWhereWithAggregatesInput {
  AND: [CountryScalarWhereWithAggregatesInput!]
  NOT: [CountryScalarWhereWithAggregatesInput!]
  OR: [CountryScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input CountryUpdateOneWithoutItemsNestedInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutItemsInput
  create: CountryCreateWithoutItemsInput
  delete: CountryWhereInput
  disconnect: CountryWhereInput
  update: CountryUpdateToOneWithWhereWithoutItemsInput
  upsert: CountryUpsertWithoutItemsInput
}

input CountryUpdateToOneWithWhereWithoutItemsInput {
  data: CountryUpdateWithoutItemsInput!
  where: CountryWhereInput
}

input CountryUpdateWithoutItemsInput {
  name: String
}

input CountryUpsertWithoutItemsInput {
  create: CountryCreateWithoutItemsInput!
  update: CountryUpdateWithoutItemsInput!
  where: CountryWhereInput
}

input CountryWhereInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  id: StringFilter
  items: ItemListRelationFilter
  name: StringFilter
}

input CountryWhereUniqueInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  id: String
  items: ItemListRelationFilter
  name: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input FloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

type Item {
  """Country object: read from the Country model by id"""
  country(where: CountryWhereInput): Country

  """
  Country ID: must be a countryId from the Country model (default value is "UN")
  """
  countryId: String

  """Creation date and time: generated on creation of item"""
  createdAt: DateTime!

  """Item ID: generated on creation (UUID v4)"""
  id: String!

  """Item image: object is generated dynamically"""
  image: ItemImage

  """Bottle name: must be unique and not empty"""
  name: String!

  """Bottle strength: must be between 0 and 100 and with 1 decimal"""
  strength: Float

  """Type object: read from the Type model by id"""
  type(where: TypeWhereInput): Type

  """Type ID: must be a typeId from the Type model (default value is "0")"""
  typeId: String

  """Update date and time: changes every time the item is updated"""
  updatedAt: DateTime!

  """User object: read from the User model by id"""
  user(where: UserWhereInput): User

  """User ID: must be a userId from the User model (default value is "0")"""
  userId: String
}

type ItemAvgAggregate {
  strength: Float
}

input ItemAvgOrderByAggregateInput {
  strength: SortOrder
}

type ItemCountAggregate {
  _all: Int!
  countryId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  strength: Int!
  typeId: Int!
  updatedAt: Int!
  userId: Int!
}

input ItemCountOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

input ItemCreateInput {
  country: CountryCreateNestedOneWithoutItemsInput
  name: String!
  strength: Float
  type: TypeCreateNestedOneWithoutItemsInput
  user: UserCreateNestedOneWithoutItemsInput
}

input ItemCreateManyInput {
  countryId: String
  name: String!
  strength: Float
  typeId: String
  userId: String
}

type ItemGroupBy {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
  countryId: String
  createdAt: DateTime!
  id: String!
  name: String!
  strength: Float
  typeId: String
  updatedAt: DateTime!
  userId: String
}

"""Item image: object with links to images of the item"""
type ItemImage {
  """Link to the original JPG image"""
  urlJpg: String!

  """Link to the JPG image with 100px width"""
  urlJpg100: String!

  """Link to the JPG image with 300px width"""
  urlJpg300: String!

  """Link to the JPG image with 500px width"""
  urlJpg500: String!

  """Link to the JPG image with 750px width"""
  urlJpg750: String!

  """Link to the JPG image with 1000px width"""
  urlJpg1000: String!

  """Link to the JPG image with 1500px width"""
  urlJpg1500: String!

  """Link to the JPG image with 2500px width"""
  urlJpg2500: String!
}

input ItemListRelationFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

type ItemMaxAggregate {
  countryId: String
  createdAt: DateTime
  id: String
  name: String
  strength: Float
  typeId: String
  updatedAt: DateTime
  userId: String
}

input ItemMaxOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

type ItemMinAggregate {
  countryId: String
  createdAt: DateTime
  id: String
  name: String
  strength: Float
  typeId: String
  updatedAt: DateTime
  userId: String
}

input ItemMinOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input ItemOrderByWithAggregationInput {
  _avg: ItemAvgOrderByAggregateInput
  _count: ItemCountOrderByAggregateInput
  _max: ItemMaxOrderByAggregateInput
  _min: ItemMinOrderByAggregateInput
  _sum: ItemSumOrderByAggregateInput
  countryId: SortOrderInput
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrderInput
  updatedAt: SortOrder
}

input ItemOrderByWithRelationInput {
  country: CountryOrderByWithRelationInput
  countryId: SortOrderInput
  createdAt: SortOrder
  name: SortOrder
  strength: SortOrderInput
  type: TypeOrderByWithRelationInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
}

enum ItemScalarFieldEnum {
  countryId
  createdAt
  id
  name
  strength
  typeId
  updatedAt
  userId
}

input ItemScalarWhereWithAggregatesInput {
  AND: [ItemScalarWhereWithAggregatesInput!]
  NOT: [ItemScalarWhereWithAggregatesInput!]
  OR: [ItemScalarWhereWithAggregatesInput!]
  countryId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  strength: FloatNullableWithAggregatesFilter
  typeId: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringNullableWithAggregatesFilter
}

type ItemSumAggregate {
  strength: Float
}

input ItemSumOrderByAggregateInput {
  strength: SortOrder
}

input ItemUpdateInput {
  country: CountryUpdateOneWithoutItemsNestedInput
  name: String
  strength: Float
  type: TypeUpdateOneWithoutItemsNestedInput
  user: UserUpdateOneWithoutItemsNestedInput
}

input ItemUpdateManyMutationInput {
  name: String
  strength: Float
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  country: CountryNullableRelationFilter
  countryId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  strength: FloatNullableFilter
  type: TypeNullableRelationFilter
  typeId: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserNullableRelationFilter
  userId: StringNullableFilter
}

input ItemWhereUniqueInput {
  AND: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  country: CountryNullableRelationFilter
  countryId: StringNullableFilter
  createdAt: DateTimeFilter
  id: String
  name: String
  strength: FloatNullableFilter
  type: TypeNullableRelationFilter
  typeId: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserNullableRelationFilter
  userId: StringNullableFilter
}

type Mutation {
  """
  Extending the generated createManyItem mutation with a field for uploading images
  """
  createManyItem(
    data: [ItemCreateManyInput!]!
    skipDuplicates: Boolean

    """
    Image upload objects: when sending files in the request, it must be filled with [null, null] (filled out on the server, check https://github.com/jaydenseric/graphql-multipart-request-spec)
    """
    uploadImages: [Upload!]
  ): AffectedRowsOutput!
  createManyType(data: [TypeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!

  """
  Extending the generated createOneItem mutation with a field for uploading an image
  """
  createOneItem(
    data: ItemCreateInput!

    """
    Image upload object: when sending a file in the request, it must be filled with null (filled out on the server, check https://github.com/jaydenseric/graphql-multipart-request-spec)
    """
    uploadImage: Upload
  ): Item!
  createOneType(data: TypeCreateInput!): Type!
  createOneUser(data: UserCreateInput!): User!
  deleteManyItem(where: ItemWhereInput): AffectedRowsOutput!
  deleteManyType(where: TypeWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneItem(where: ItemWhereUniqueInput!): Item
  deleteOneType(where: TypeWhereUniqueInput!): Type
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyItem(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): AffectedRowsOutput!
  updateManyType(data: TypeUpdateManyMutationInput!, where: TypeWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!

  """
  Extending the generated updateOneItem mutation with fields for uploading or deleting an image
  """
  updateOneItem(
    data: ItemUpdateInput!

    """Image deletion flag: cannot be set at the same time as uploadImage"""
    deleteImage: Boolean

    """
    Image upload object: when sending a file in the request, it must be filled with null (filled out on the server, check https://github.com/jaydenseric/graphql-multipart-request-spec)
    """
    uploadImage: Upload
    where: ItemWhereUniqueInput!
  ): Item!
  updateOneType(data: TypeUpdateInput!, where: TypeWhereUniqueInput!): Type
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User

  """
  Extending the generated upsertOneItem mutation with a fields for uploading or deleting an image
  """
  upsertOneItem(
    create: ItemCreateInput!

    """Image deletion flag: cannot be set at the same time as uploadImage"""
    deleteImage: Boolean
    update: ItemUpdateInput!

    """
    Image upload object: when sending a file in the request, it must be filled with null (filled out on the server, check https://github.com/jaydenseric/graphql-multipart-request-spec)
    """
    uploadImage: Upload
    where: ItemWhereUniqueInput!
  ): Item!
  upsertOneType(create: TypeCreateInput!, update: TypeUpdateInput!, where: TypeWhereUniqueInput!): Type!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Query {
  aggregateCountry(cursor: CountryWhereUniqueInput, orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): AggregateCountry!
  aggregateItem(cursor: ItemWhereUniqueInput, orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): AggregateItem!
  aggregateType(cursor: TypeWhereUniqueInput, orderBy: [TypeOrderByWithRelationInput!], skip: Int, take: Int, where: TypeWhereInput): AggregateType!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  countries(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): [Country!]!
  findFirstCountryOrThrow(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): Country
  findFirstItemOrThrow(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): Item
  findFirstTypeOrThrow(cursor: TypeWhereUniqueInput, distinct: [TypeScalarFieldEnum!], orderBy: [TypeOrderByWithRelationInput!], skip: Int, take: Int, where: TypeWhereInput): Type
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCountry(where: CountryWhereUniqueInput!): Country
  getItem(where: ItemWhereUniqueInput!): Item
  getType(where: TypeWhereUniqueInput!): Type
  getUser(where: UserWhereUniqueInput!): User
  groupByCountry(by: [CountryScalarFieldEnum!]!, having: CountryScalarWhereWithAggregatesInput, orderBy: [CountryOrderByWithAggregationInput!], skip: Int, take: Int, where: CountryWhereInput): [CountryGroupBy!]!
  groupByItem(by: [ItemScalarFieldEnum!]!, having: ItemScalarWhereWithAggregatesInput, orderBy: [ItemOrderByWithAggregationInput!], skip: Int, take: Int, where: ItemWhereInput): [ItemGroupBy!]!
  groupByType(by: [TypeScalarFieldEnum!]!, having: TypeScalarWhereWithAggregatesInput, orderBy: [TypeOrderByWithAggregationInput!], skip: Int, take: Int, where: TypeWhereInput): [TypeGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  types(cursor: TypeWhereUniqueInput, distinct: [TypeScalarFieldEnum!], orderBy: [TypeOrderByWithRelationInput!], skip: Int, take: Int, where: TypeWhereInput): [Type!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

"""User roles: for authorization (USER, ADMIN)"""
enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Type {
  _count: TypeCount

  """Type ID: generated on creation (UUID v4)"""
  id: String!

  """Type items: all items with this type"""
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!

  """Type of alcohol: must be unique and not empty"""
  name: String!
}

type TypeCount {
  items(where: ItemWhereInput): Int!
}

type TypeCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input TypeCountOrderByAggregateInput {
  name: SortOrder
}

input TypeCreateInput {
  name: String!
}

input TypeCreateManyInput {
  name: String!
}

input TypeCreateNestedOneWithoutItemsInput {
  connect: TypeWhereUniqueInput
  connectOrCreate: TypeCreateOrConnectWithoutItemsInput
  create: TypeCreateWithoutItemsInput
}

input TypeCreateOrConnectWithoutItemsInput {
  create: TypeCreateWithoutItemsInput!
  where: TypeWhereUniqueInput!
}

input TypeCreateWithoutItemsInput {
  name: String!
}

type TypeGroupBy {
  _count: TypeCountAggregate
  _max: TypeMaxAggregate
  _min: TypeMinAggregate
  id: String!
  name: String!
}

type TypeMaxAggregate {
  id: String
  name: String
}

input TypeMaxOrderByAggregateInput {
  name: SortOrder
}

type TypeMinAggregate {
  id: String
  name: String
}

input TypeMinOrderByAggregateInput {
  name: SortOrder
}

input TypeNullableRelationFilter {
  is: TypeWhereInput
  isNot: TypeWhereInput
}

input TypeOrderByWithAggregationInput {
  _count: TypeCountOrderByAggregateInput
  _max: TypeMaxOrderByAggregateInput
  _min: TypeMinOrderByAggregateInput
  name: SortOrder
}

input TypeOrderByWithRelationInput {
  items: ItemOrderByRelationAggregateInput
  name: SortOrder
}

enum TypeScalarFieldEnum {
  id
  name
}

input TypeScalarWhereWithAggregatesInput {
  AND: [TypeScalarWhereWithAggregatesInput!]
  NOT: [TypeScalarWhereWithAggregatesInput!]
  OR: [TypeScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input TypeUpdateInput {
  name: String
}

input TypeUpdateManyMutationInput {
  name: String
}

input TypeUpdateOneWithoutItemsNestedInput {
  connect: TypeWhereUniqueInput
  connectOrCreate: TypeCreateOrConnectWithoutItemsInput
  create: TypeCreateWithoutItemsInput
  delete: TypeWhereInput
  disconnect: TypeWhereInput
  update: TypeUpdateToOneWithWhereWithoutItemsInput
  upsert: TypeUpsertWithoutItemsInput
}

input TypeUpdateToOneWithWhereWithoutItemsInput {
  data: TypeUpdateWithoutItemsInput!
  where: TypeWhereInput
}

input TypeUpdateWithoutItemsInput {
  name: String
}

input TypeUpsertWithoutItemsInput {
  create: TypeCreateWithoutItemsInput!
  update: TypeUpdateWithoutItemsInput!
  where: TypeWhereInput
}

input TypeWhereInput {
  AND: [TypeWhereInput!]
  NOT: [TypeWhereInput!]
  OR: [TypeWhereInput!]
  id: StringFilter
  items: ItemListRelationFilter
  name: StringFilter
}

input TypeWhereUniqueInput {
  AND: [TypeWhereInput!]
  NOT: [TypeWhereInput!]
  OR: [TypeWhereInput!]
  id: String
  items: ItemListRelationFilter
  name: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  _count: UserCount

  """Creation date and time: generated on creation of user"""
  createdAt: DateTime!

  """
  User email: must be unique and a valid email (check isEmail() on https://github.com/validatorjs/validator.js#validators)
  """
  email: String!

  """User ID: generated on creation (UUID v4)"""
  id: String!

  """User items: all items for this user"""
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!

  """User name: must be unique and between 4 and 20 characters"""
  name: String!

  """User role: new users are set to "USER" by default"""
  role: Role!

  """Update date and time: changes every time the user is updated"""
  updatedAt: DateTime!
}

type UserCount {
  items(where: ItemWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  email: String!
  name: String!
  password: String!
}

input UserCreateNestedOneWithoutItemsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutItemsInput
  create: UserCreateWithoutItemsInput
}

input UserCreateOrConnectWithoutItemsInput {
  create: UserCreateWithoutItemsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutItemsInput {
  email: String!
  name: String!
  password: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime!
  email: String!
  id: String!
  name: String!
  password: String!
  role: Role!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  password: String
  role: Role
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: String
  name: String
  password: String
  role: Role
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  items: ItemOrderByRelationAggregateInput
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  password
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  email: String
  name: String
  password: String
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
}

input UserUpdateOneWithoutItemsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutItemsInput
  create: UserCreateWithoutItemsInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutItemsInput
  upsert: UserUpsertWithoutItemsInput
}

input UserUpdateToOneWithWhereWithoutItemsInput {
  data: UserUpdateWithoutItemsInput!
  where: UserWhereInput
}

input UserUpdateWithoutItemsInput {
  email: String
  name: String
  password: String
}

input UserUpsertWithoutItemsInput {
  create: UserCreateWithoutItemsInput!
  update: UserUpdateWithoutItemsInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  items: ItemListRelationFilter
  name: StringFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: String
  id: String
  items: ItemListRelationFilter
  name: String
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}